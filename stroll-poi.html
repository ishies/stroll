<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Stroll App - Nearby POI</title>
    
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Clarendon', 'Georgia', serif;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        }

        .phone-container {
            width: 320px;
            height: 600px;
            background: linear-gradient(180deg, #a8d5ba 0%, #6fb583 50%, #4a9b63 100%);
            border-radius: 30px;
            padding: 40px 25px;
            position: relative;
            overflow: hidden;
            box-shadow: 0 20px 60px rgba(0,0,0,0.3);
        }

        .back-arrow {
            position: absolute;
            top: 30px;
            left: 25px;
            width: 35px;
            height: 35px;
            background: rgba(255,255,255,0.3);
            border-radius: 10px;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-size: 18px;
            cursor: pointer;
            z-index: 10;
            transition: background 0.2s;
        }

        .back-arrow:hover {
            background: rgba(255,255,255,0.4);
        }

        .top-actions {
            position: absolute;
            top: 30px;
            right: 25px;
            display: flex;
            gap: 10px;
            z-index: 10;
        }

        .action-btn {
            width: 35px;
            height: 35px;
            background: rgba(255,255,255,0.3);
            border-radius: 10px;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-size: 18px;
            cursor: pointer;
            border: none;
            transition: all 0.3s;
        }

        .action-btn:hover {
            background: rgba(255,255,255,0.4);
            transform: scale(1.05);
        }

        .action-btn:active {
            transform: scale(0.95);
        }

        .heart-btn.liked {
            background: rgba(255,255,255,0.9);
            color: #e53e3e;
            animation: heartPulse 0.3s ease-in-out;
        }

        @keyframes heartPulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.2); }
        }

        .refresh-btn.spinning {
            animation: spin 0.6s ease-in-out;
        }

        .refresh-icon {
            width: 20px;
            height: 20px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .refresh-icon svg {
            width: 100%;
            height: 100%;
        }

        .content {
            position: relative;
            z-index: 5;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding-top: 60px;
        }

        .map-container {
            width: 100%;
            height: 220px;
            background: white;
            border-radius: 20px;
            overflow: hidden;
            box-shadow: 0 4px 20px rgba(0,0,0,0.15);
            margin-bottom: 15px;
        }

        .map-image {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }

        h1 {
            color: white;
            font-size: 24px;
            font-weight: 700;
            margin-bottom: 15px;
            text-shadow: 0 2px 10px rgba(0,0,0,0.2);
        }

        .poi-box {
            width: 100%;
            background: white;
            border-radius: 16px;
            padding: 18px;
            box-shadow: 0 4px 15px rgba(0,0,0,0.1);
            margin-bottom: 20px;
        }

        .poi-name {
            font-size: 18px;
            font-weight: 700;
            color: #2d3748;
            margin-bottom: 6px;
        }

        .poi-distance {
            font-size: 15px;
            color: #718096;
        }

        .button {
            width: 100%;
            padding: 14px;
            border: none;
            border-radius: 15px;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
            font-family: 'Clarendon', 'Georgia', serif;
            background: linear-gradient(135deg, #8b5a3c 0%, #a0745c 100%);
            color: white;
            box-shadow: 0 4px 15px rgba(139,90,60,0.4);
        }

        .button:hover {
            box-shadow: 0 6px 20px rgba(139,90,60,0.5);
        }

        .button:active {
            transform: scale(0.98);
        }

        .loading {
            display: inline-block;
            width: 20px;
            height: 20px;
            border: 3px solid rgba(255,255,255,0.3);
            border-radius: 50%;
            border-top-color: white;
            animation: spin 1s ease-in-out infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .route-info {
            color: rgba(255,255,255,0.9);
            font-size: 12px;
            margin-bottom: 10px;
            text-align: center;
        }
    </style>
</head>
<body>
    <div class="phone-container">
        <div class="back-arrow" onclick="window.history.back()">‚Äπ</div>
        
        <div class="top-actions">
            <button class="action-btn refresh-btn" id="refreshBtn" title="Refresh POI">
                <div class="refresh-icon">
                    <svg viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
                        <path d="M4 12C4 7.58172 7.58172 4 12 4C14.5264 4 16.7792 5.17108 18.2454 7" stroke="white" stroke-width="2.5" stroke-linecap="round"/>
                        <path d="M20 12C20 16.4183 16.4183 20 12 20C9.47362 20 7.22082 18.8289 5.75463 17" stroke="white" stroke-width="2.5" stroke-linecap="round"/>
                        <path d="M17 7L18.5 7L18.5 5.5" stroke="white" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round"/>
                        <path d="M7 17L5.5 17L5.5 18.5" stroke="white" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round"/>
                    </svg>
                </div>
            </button>
            <button class="action-btn heart-btn" id="heartBtn" title="Like this POI">
                ‚ô°
            </button>
        </div>
        
        <div class="content">
            <div class="map-container" id="map"></div>
            
            <p class="route-info" id="routeInfo">Loading route...</p>
            <h1>POI Along Route</h1>
            
            <div class="poi-box">
                <div class="poi-name" id="poiName">Finding POI...</div>
                <div class="poi-distance" id="poiAddress">Please wait</div>
            </div>
            
            <button class="button" id="detailsBtn">See Details</button>
        </div>
    </div>

    <script type="module">
        import { initializeApp } from 'https://www.gstatic.com/firebasejs/10.8.0/firebase-app.js';
        import { getAuth, onAuthStateChanged } from 'https://www.gstatic.com/firebasejs/10.8.0/firebase-auth.js';
        import { getFirestore, collection, getDocs, query, where, limit, doc, updateDoc, serverTimestamp } from 'https://www.gstatic.com/firebasejs/10.8.0/firebase-firestore.js';
        
        const firebaseConfig = {
            apiKey: "AIzaSyCZlUYoU77T2cBHTxlQW6FWaMVX_0yZ5rc",
            authDomain: "stroll-c5285.firebaseapp.com",
            projectId: "stroll-c5285",
            storageBucket: "stroll-c5285.firebasestorage.app",
            messagingSenderId: "465458957302",
            appId: "1:465458957302:web:1b104b86069514164615d7",
            measurementId: "G-PZY4GX7SSE"
        };

        let currentPOI = null;
        let isLiked = false;
        let userPreferences = {};
        let db = null;
        let auth = null;
        let shownPOIs = [];
        let currentUserUID = null;
        let userDocId = null;
        let routePolyline = null;
        let routeData = null;
        let map = null;
        let directionsService = null;
        let directionsRenderer = null;
        let poiMarker = null;
        let startMarker = null;
        let endMarker = null;

        // Get route from sessionStorage
        const savedRoute = sessionStorage.getItem('strollRoute');
        const routeInfo = savedRoute ? JSON.parse(savedRoute) : null;

        function parseAmenities(raw) {
            if (!raw) return [];
            if (typeof raw === 'string') {
                const tupleRegex = /\(\s*([^,]+?)\s*,\s*(\d+)\s*\)/g;
                const matches = [];
                let match;
                while ((match = tupleRegex.exec(raw)) !== null) {
                    matches.push({ amenity: match[1].trim(), frequency: Number(match[2]) || 1 });
                }
                if (matches.length > 0) return matches;
            }
            if (Array.isArray(raw)) {
                return raw.map(item => {
                    if (Array.isArray(item)) return { amenity: item[0], frequency: Number(item[1]) || 0 };
                    if (typeof item === 'object') {
                        const amen = item.amenity || item.name || item[0];
                        const freq = item.frequency || item.freq || item.count || 1;
                        return { amenity: amen, frequency: Number(freq) || 0 };
                    }
                    return { amenity: String(item), frequency: 1 };
                });
            }
            return [{ amenity: String(raw), frequency: 1 }];
        }

        function weightedPick(items) {
            const total = items.reduce((s, it) => s + (Number(it.frequency) || 0), 0);
            if (total <= 0) return items[Math.floor(Math.random() * items.length)];
            let r = Math.random() * total;
            for (const it of items) {
                r -= (Number(it.frequency) || 0);
                if (r <= 0) return it;
            }
            return items[items.length - 1];
        }

        // Calculate distance from point to line segment (in meters)
        function distanceToSegment(point, segmentStart, segmentEnd) {
            const R = 6371000; // Earth radius in meters
            
            // Convert to radians
            const lat1 = point.lat * Math.PI / 180;
            const lng1 = point.lng * Math.PI / 180;
            const lat2 = segmentStart.lat * Math.PI / 180;
            const lng2 = segmentStart.lng * Math.PI / 180;
            const lat3 = segmentEnd.lat * Math.PI / 180;
            const lng3 = segmentEnd.lng * Math.PI / 180;
            
            // Haversine distance from point to segment start
            const dLat1 = lat1 - lat2;
            const dLng1 = lng1 - lng2;
            const a1 = Math.sin(dLat1/2) * Math.sin(dLat1/2) +
                      Math.cos(lat2) * Math.cos(lat1) *
                      Math.sin(dLng1/2) * Math.sin(dLng1/2);
            const c1 = 2 * Math.atan2(Math.sqrt(a1), Math.sqrt(1-a1));
            const dist1 = R * c1;
            
            // Haversine distance from point to segment end
            const dLat2 = lat1 - lat3;
            const dLng2 = lng1 - lng3;
            const a2 = Math.sin(dLat2/2) * Math.sin(dLat2/2) +
                      Math.cos(lat3) * Math.cos(lat1) *
                      Math.sin(dLng2/2) * Math.sin(dLng2/2);
            const c2 = 2 * Math.atan2(Math.sqrt(a2), Math.sqrt(1-a2));
            const dist2 = R * c2;
            
            return Math.min(dist1, dist2);
        }

        // Check if POI is along the route (within 1000m of any route segment)
        function isAlongRoute(poiLat, poiLng, maxDistance = 1000) {
            if (!routePolyline || routePolyline.length < 2) {
                console.log('‚ö†Ô∏è No route polyline available');
                return false;
            }
            
            const poiPoint = { lat: poiLat, lng: poiLng };
            let minDistance = Infinity;
            
            for (let i = 0; i < routePolyline.length - 1; i++) {
                const segmentStart = routePolyline[i];
                const segmentEnd = routePolyline[i + 1];
                const distance = distanceToSegment(poiPoint, segmentStart, segmentEnd);
                
                if (distance < minDistance) {
                    minDistance = distance;
                }
                
                if (distance <= maxDistance) {
                    console.log('   ‚úÖ Within', Math.round(distance), 'm of route');
                    return true;
                }
            }
            
            console.log('   ‚ùå Closest point:', Math.round(minDistance), 'm away (max:', maxDistance, 'm)');
            return false;
        }

        async function getRouteFromGoogle() {
            if (!routeInfo) {
                console.warn('No route info found');
                return false;
            }

            try {
                const request = {
                    origin: routeInfo.starting,
                    destination: routeInfo.destination,
                    travelMode: google.maps.TravelMode.WALKING
                };

                const result = await new Promise((resolve, reject) => {
                    directionsService.route(request, (result, status) => {
                        if (status === 'OK') {
                            resolve(result);
                        } else {
                            reject(new Error('Directions request failed: ' + status));
                        }
                    });
                });

                // Don't use directionsRenderer (it adds its own markers)
                // Instead, manually draw the route
                const route = result.routes[0];
                routeData = result;
                
                // Extract polyline points from the route
                routePolyline = [];
                route.overview_path.forEach(point => {
                    routePolyline.push({
                        lat: point.lat(),
                        lng: point.lng()
                    });
                });

                // Draw the route path
                const routePath = new google.maps.Polyline({
                    path: routePolyline,
                    geodesic: true,
                    strokeColor: '#4A90E2',
                    strokeOpacity: 0.8,
                    strokeWeight: 4,
                    map: map
                });

                // Add custom start marker (green)
                const leg = route.legs[0];
                startMarker = new google.maps.Marker({
                    position: leg.start_location,
                    map: map,
                    title: 'Start: ' + routeInfo.starting,
                    label: {
                        text: 'A',
                        color: 'white',
                        fontWeight: 'bold'
                    },
                    icon: {
                        path: google.maps.SymbolPath.CIRCLE,
                        scale: 12,
                        fillColor: '#4CAF50',
                        fillOpacity: 1,
                        strokeColor: '#ffffff',
                        strokeWeight: 3
                    }
                });

                // Add custom end marker (red)
                endMarker = new google.maps.Marker({
                    position: leg.end_location,
                    map: map,
                    title: 'End: ' + routeInfo.destination,
                    label: {
                        text: 'B',
                        color: 'white',
                        fontWeight: 'bold'
                    },
                    icon: {
                        path: google.maps.SymbolPath.CIRCLE,
                        scale: 12,
                        fillColor: '#F44336',
                        fillOpacity: 1,
                        strokeColor: '#ffffff',
                        strokeWeight: 3
                    }
                });

                // Update route info display
                document.getElementById('routeInfo').textContent = 
                    `${leg.distance.text} ‚Ä¢ ${leg.duration.text}`;

                // Fit map to show entire route
                const bounds = new google.maps.LatLngBounds();
                routePolyline.forEach(point => bounds.extend(point));
                map.fitBounds(bounds);

                console.log('‚úÖ Route loaded:', routePolyline.length, 'points');
                console.log('üìç Start:', leg.start_location.lat(), leg.start_location.lng());
                console.log('üìç End:', leg.end_location.lat(), leg.end_location.lng());
                
                return true;
            } catch (err) {
                console.error('‚ùå Error getting route:', err);
                document.getElementById('routeInfo').textContent = 'Route unavailable';
                return false;
            }
        }

        async function loadPOIWithFirebase() {
            try {
                if (!currentUserUID) {
                    console.warn('No user UID available');
                    return;
                }

                const usersRef = collection(db, 'users');
                const q = query(usersRef, where('uid', '==', currentUserUID));
                const userQuerySnap = await getDocs(q);

                if (userQuerySnap.empty) {
                    console.warn('No user profile found');
                    return;
                }

                const userDoc = userQuerySnap.docs[0];
                userDocId = userDoc.id;
                const userData = userDoc.data();
                const cluster = userData.Cluster;
                
                console.log('‚úÖ User cluster:', cluster);

                const rawPrefs = userData.preferences;
                userPreferences = {};
                
                if (rawPrefs && typeof rawPrefs === 'object') {
                    for (const key in rawPrefs) {
                        userPreferences[key] = typeof rawPrefs[key] === 'number' ? 
                            rawPrefs[key] : parseInt(rawPrefs[key]) || 0;
                    }
                    console.log('üìä Current user preferences:', userPreferences);
                } else {
                    console.log('‚ö†Ô∏è No existing preferences found');
                }

                const centroidsRef = collection(db, 'clusters');
                const centQ = query(centroidsRef, where('Cluster', '==', cluster), limit(1));
                const centSnap = await getDocs(centQ);

                if (centSnap.empty) {
                    console.warn('No centroid found');
                    return;
                }

                const centroid = centSnap.docs[0].data();
                const amenities = parseAmenities(centroid.amenities || centroid.Amenities);

                if (!amenities || amenities.length === 0) {
                    console.warn('No amenities in centroid');
                    return;
                }

                if (Object.keys(userPreferences).length === 0) {
                    console.log('üÜï Initializing preferences from cluster amenities');
                    amenities.forEach(a => {
                        userPreferences[a.amenity] = a.frequency;
                    });
                    console.log('‚úÖ Initial preferences set:', userPreferences);
                    await savePreferencesToFirebase();
                } else {
                    console.log('‚úÖ Using existing preferences');
                }

                // Get variability from localStorage
                const variability = parseInt(localStorage.getItem('strollVariability') || '20');
                const explorationRate = variability / 100;
                
                console.log('üé≤ Exploration rate:', explorationRate * 100 + '%');

                let amenityChoice;
                
                if (Math.random() < explorationRate) {
                    const randomAmenity = amenities[Math.floor(Math.random() * amenities.length)];
                    amenityChoice = randomAmenity.amenity;
                    console.log('üîç EXPLORING (random choice):', amenityChoice);
                } else {
                    const weightedAmenities = amenities.map(a => ({
                        amenity: a.amenity,
                        frequency: userPreferences[a.amenity] || 1
                    }));
                    console.log('üéØ Weighted options:', weightedAmenities);
                    const picked = weightedPick(weightedAmenities);
                    amenityChoice = picked.amenity;
                    console.log('‚úÖ Using preference-based choice:', amenityChoice, '(weight:', picked.frequency, ')');
                }

                const poisRef = collection(db, 'pois');
                const poisQ = query(poisRef, where('amenity', '==', amenityChoice));
                const poisSnap = await getDocs(poisQ);

                console.log('üîç Querying POIs with amenity:', amenityChoice);
                console.log('üîç Query result - empty?:', poisSnap.empty);
                console.log('üîç Total POIs returned:', poisSnap.docs.length);

                if (poisSnap.empty || poisSnap.docs.length === 0) {
                    console.warn('‚ùå No POIs found for amenity:', amenityChoice);
                    
                    // Try to find ANY POI to debug
                    console.log('üîç Fetching sample POIs to understand database structure...');
                    const allPoisQ = query(poisRef, limit(10));
                    const allPoisSnap = await getDocs(allPoisQ);
                    console.log('üìä Sample query returned:', allPoisSnap.docs.length, 'POIs');
                    
                    if (allPoisSnap.empty) {
                        console.error('‚ùå‚ùå‚ùå Your POIs collection appears to be EMPTY!');
                        return;
                    }
                    
                    allPoisSnap.docs.forEach((d, idx) => {
                        const data = d.data();
                        console.log(`  ${idx + 1}.`, data.name || 'Unnamed', '|', 
                                   'amenity:', data.amenity, '|',
                                   'type:', data.type, '|',
                                   'coords: X=', data.X, 'Y=', data.Y);
                        if (idx === 0) {
                            console.log('     All fields:', Object.keys(data));
                        }
                    });
                    
                    // Show what amenity values exist
                    const amenitySet = new Set();
                    allPoisSnap.docs.forEach(d => {
                        const amenity = d.data().amenity;
                        if (amenity) amenitySet.add(amenity);
                    });
                    console.log('üìã Sample amenity values in database:', Array.from(amenitySet));
                    
                    return;
                }

                // Filter POIs to only those along the route
                console.log('üîç Total POIs before filtering:', poisSnap.docs.length);
                console.log('üìç Route has', routePolyline ? routePolyline.length : 0, 'points');
                
                let routePOIs;
                
                if (!routePolyline || routePolyline.length < 2) {
                    console.error('‚ùå Route polyline not loaded properly!');
                    // Don't filter by route if we don't have route data
                    routePOIs = poisSnap.docs;
                } else {
                    console.log('üìç Route bounds:', {
                        firstPoint: routePolyline[0],
                        lastPoint: routePolyline[routePolyline.length - 1]
                    });
                    
                    routePOIs = poisSnap.docs.filter(d => {
                        const data = d.data();
                        
                        // Try multiple possible coordinate field names (including capital X, Y)
                        const lat = data.Y || data.y || data.lat || data.latitude || data.Latitude;
                        const lng = data.X || data.x || data.lon || data.lng || data.longitude || data.Longitude;
                        
                        console.log('üìå Checking POI:', data.name || 'Unnamed');
                        console.log('   Raw data fields:', Object.keys(data));
                        console.log('   Extracted coords: lat=', lat, 'lng=', lng);
                        console.log('   Y=', data.Y, 'X=', data.X);
                        
                        if (!lat || !lng) {
                            console.log('   ‚ùå Missing coordinates');
                            return false;
                        }
                        
                        const isAlong = isAlongRoute(lat, lng, 1000); // Increased to 1km
                        
                        return isAlong;
                    });
                }

                console.log('üìç Found', routePOIs.length, 'POIs along route out of', poisSnap.docs.length, 'total');

                if (routePOIs.length === 0) {
                    console.warn('‚ö†Ô∏è No POIs along route, showing all available');
                    routePOIs = poisSnap.docs;
                }

                // Filter out already shown POIs
                let availableDocs = routePOIs.filter(d => !shownPOIs.includes(d.id));
                if (availableDocs.length === 0) {
                    shownPOIs = [];
                    availableDocs = routePOIs;
                }

                const chosenDoc = availableDocs[Math.floor(Math.random() * availableDocs.length)];
                currentPOI = { ...chosenDoc.data(), _id: chosenDoc.id };
                shownPOIs.push(chosenDoc.id);
                if (shownPOIs.length > 10) shownPOIs.shift();

                console.log('‚úÖ Selected POI:', currentPOI.name);
                console.log('üì¶ POI data:', currentPOI);

                updateUI();

            } catch (err) {
                console.error('Firebase error:', err);
            }
        }

        function updateUI() {
            document.getElementById('poiName').textContent = currentPOI.name || 'Recommended Place';
            document.getElementById('poiAddress').textContent = currentPOI.address || '';
            
            isLiked = false;
            const heartBtn = document.getElementById('heartBtn');
            heartBtn.textContent = '‚ô°';
            heartBtn.classList.remove('liked');
            
            // Add POI marker to map
            if (map && currentPOI) {
                // Use capital X, Y from your database
                const lat = currentPOI.Y || currentPOI.y || currentPOI.lat || currentPOI.latitude;
                const lng = currentPOI.X || currentPOI.x || currentPOI.lon || currentPOI.lng || currentPOI.longitude;
                
                console.log('üó∫Ô∏è Adding POI to map:', currentPOI.name);
                console.log('   Coordinates: lat=', lat, 'lng=', lng);
                
                if (lat && lng) {
                    // Remove old marker if exists
                    if (poiMarker) {
                        poiMarker.setMap(null);
                    }
                    
                    // Add new POI marker (brown/coffee color)
                    poiMarker = new google.maps.Marker({
                        position: { lat: parseFloat(lat), lng: parseFloat(lng) },
                        map: map,
                        title: currentPOI.name || 'POI',
                        label: {
                            text: '‚òÖ',
                            color: 'white',
                            fontSize: '18px',
                            fontWeight: 'bold'
                        },
                        icon: {
                            path: google.maps.SymbolPath.CIRCLE,
                            scale: 15,
                            fillColor: '#8b5a3c',
                            fillOpacity: 1,
                            strokeColor: '#ffffff',
                            strokeWeight: 3
                        },
                        zIndex: 1000
                    });
                    
                    // Adjust map bounds to include POI
                    const bounds = new google.maps.LatLngBounds();
                    if (startMarker) bounds.extend(startMarker.getPosition());
                    if (endMarker) bounds.extend(endMarker.getPosition());
                    bounds.extend({ lat: parseFloat(lat), lng: parseFloat(lng) });
                    map.fitBounds(bounds);
                    
                    console.log('‚úÖ POI marker added successfully at:', lat, lng);
                } else {
                    console.warn('‚ö†Ô∏è No coordinates found for POI');
                    console.warn('   Available fields:', Object.keys(currentPOI));
                }
            }
        }

        async function savePreferencesToFirebase() {
            try {
                if (!currentUserUID || !db || !userDocId) {
                    console.warn('‚ö†Ô∏è Cannot save preferences - missing:', {
                        hasUID: !!currentUserUID,
                        hasDB: !!db,
                        hasDocId: !!userDocId
                    });
                    return false;
                }
                
                console.log('üíæ Saving preferences to Firebase...');
                console.log('   Document ID:', userDocId);
                console.log('   Preferences to save:', userPreferences);
                
                const userRef = doc(db, 'users', userDocId);
                await updateDoc(userRef, { 
                    preferences: userPreferences,
                    UpdatedAt: serverTimestamp()
                });
                
                console.log('‚úÖ‚úÖ‚úÖ Preferences saved successfully to Firebase!');
                console.log('üìä Saved preferences:', JSON.stringify(userPreferences, null, 2));
                return true;
            } catch (err) {
                console.error('‚ùå Error saving preferences:', err);
                console.error('Error details:', err.message);
                return false;
            }
        }

        async function handleLike() {
            if (!currentPOI) return;

            const amenityType = currentPOI.amenity || currentPOI.type;
            if (!amenityType) {
                console.error('‚ùå No amenity type');
                return;
            }
            
            if (!isLiked) {
                isLiked = true;
                userPreferences[amenityType] = (userPreferences[amenityType] || 0) + 1;
                console.log('‚ù§Ô∏è LIKED:', amenityType, '- New count:', userPreferences[amenityType]);
                console.log('üìä Updated preferences:', userPreferences);
            } else {
                isLiked = false;
                if (userPreferences[amenityType] > 0) {
                    userPreferences[amenityType]--;
                    if (userPreferences[amenityType] === 0) {
                        delete userPreferences[amenityType];
                    }
                }
                console.log('üíî UNLIKED:', amenityType, '- New count:', userPreferences[amenityType] || 0);
                console.log('üìä Updated preferences:', userPreferences);
            }

            const heartBtn = document.getElementById('heartBtn');
            heartBtn.textContent = isLiked ? '‚ô•' : '‚ô°';
            heartBtn.classList.toggle('liked', isLiked);
            
            await savePreferencesToFirebase();
        }

        function handleRefresh() {
            const refreshBtn = document.getElementById('refreshBtn');
            refreshBtn.classList.add('spinning');
            setTimeout(() => refreshBtn.classList.remove('spinning'), 600);
            
            loadPOIWithFirebase();
        }

        async function init() {
            try {
                const app = initializeApp(firebaseConfig);
                auth = getAuth(app);
                db = getFirestore(app);
                
                console.log('‚úÖ Firebase initialized');

                onAuthStateChanged(auth, async (user) => {
                    if (!user) {
                        console.error('‚ùå No user authenticated');
                        window.location.href = 'stroll-signin.html';
                        return;
                    }

                    currentUserUID = user.uid;
                    console.log('‚úÖ User authenticated:', currentUserUID);
                    
                    // Initialize Google Maps
                    if (typeof google !== 'undefined') {
                        directionsService = new google.maps.DirectionsService();
                        
                        map = new google.maps.Map(document.getElementById('map'), {
                            zoom: 14,
                            center: { lat: 40.7580, lng: -73.9855 },
                            mapTypeControl: false,
                            streetViewControl: false,
                            fullscreenControl: false
                        });
                        
                        console.log('üó∫Ô∏è Map initialized');
                        
                        // Get route first, then load POIs
                        const routeLoaded = await getRouteFromGoogle();
                        if (routeLoaded) {
                            await loadPOIWithFirebase();
                        }
                    }
                });
            } catch (err) {
                console.error('‚ùå Init error:', err);
            }
        }

        window.addEventListener('load', () => {
            init();
            
            document.getElementById('heartBtn').addEventListener('click', handleLike);
            document.getElementById('refreshBtn').addEventListener('click', handleRefresh);
            
            document.getElementById('detailsBtn').addEventListener('click', () => {
                if (currentPOI) {
                    const lat = currentPOI.y || currentPOI.lat || currentPOI.latitude;
                    const lon = currentPOI.x || currentPOI.lon || currentPOI.lng || currentPOI.longitude;
                    
                    let mapsUrl = '';
                    if (lat && lon) {
                        mapsUrl = `https://www.google.com/maps/search/?api=1&query=${lat},${lon}`;
                    } else {
                        const searchQuery = currentPOI.name && currentPOI.address ? 
                            `${currentPOI.name}, ${currentPOI.address}` : 
                            currentPOI.name || currentPOI.address;
                        mapsUrl = `https://www.google.com/maps/search/?api=1&query=${encodeURIComponent(searchQuery)}`;
                    }
                    
                    window.open(mapsUrl, '_blank');
                }
            });
        });
    </script>
    <script src="https://maps.googleapis.com/maps/api/js?key=AIzaSyC9QL4PQdqupzoE-VPz0R-L6aKsknVZchY&libraries=places" async defer></script>
</body>
</html>
